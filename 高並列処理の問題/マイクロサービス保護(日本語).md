# マイクロサービス保護

## 1. マイクロサービスのリモート呼び出しにおける問題点

### 1.1 業務の堅牢性問題
**シナリオ例**：ショッピングカート照会業務
- カートサービスは商品情報を照会してデータ比較が必要  
- 商品サービスの障害がカート照会異常を引き起こす  
- **業務要件**：商品照会が失敗してもカートリストを正常表示（旧データでダウングレード表示可能）

### 1.2 連鎖的失敗（雪だるま効果）
**発生プロセス**：  
1. 商品サービス高同時接続 → Tomcat接続過剰占有 → インターフェース応答遅延/ブロック  
2. カートサービスが商品照会を待機 → 応答時間延長 → 徐々にブロック  
3. カートリクエスト蓄積 → 更なる接続占有 → サービス性能低下  
4. 連鎖反応 → 関連マイクロサービス相次ぐ障害 → クラスター不能  

---

## 2. マイクロサービス保護ソリューション

### 2.1 コア保護戦略
| ソリューション | 作用原理                          | 効果                          | 代償                  |
|--------------|-----------------------------------|-----------------------------|-----------------------|
| リクエストレート制限 | インターフェース同時接続数を制限   | 突発トラフィックの平滑化     | ピーク処理能力低下    |
| スレッド隔離   | 独立スレッドプールリソースを割当   | 障害サービスの隔離           | 利用可能リソース総量減少 |
| サーキットブレーカー | 異常統計+自動ダウングレード       | システム保護のための高速失敗  | 一部サービス弱可用化  |

### 2.1.1 リクエストレート制限
**実装例え**：  
> 水力発電所のダムのように、変動するリクエスト流量を安定出力に変換

**要点**：
- QPS閾値設定
- 超過リクエストは直接拒否/キューイング

### 2.1.2 スレッド隔離
**典型的なシナリオ**：  
- 高同時接続+長応答インターフェース → スレッドリソース枯渇 ，
- 他の正常インターフェースに影響  

**解決策**：  
- サービス別に独立スレッドプールを割当
- 障害サービスが全リソースを占有しない

### 2.1.3 サーキットブレーカー
**スレッド隔離の限界**：  
- 障害サービスが呼び出し元の応答を遅延させる  
- コア機能不能の可能性  

**メカニズム**：  
1. **ダウングレードロジック**（Fallback）：  
   - デフォルト戻り値  
   - ユーザーフレンドリーな通知  
   - 例外スロー  
2. **トリガー条件**：  
   - 異常比率統計（例：50%）  
   - 閾値超で自動ダウングレード発動  
   - 熔断後は高速失敗  

**状態遷移**：  
- 閉鎖 → 異常閾値超過 → 開放 → 冷却期間 → 半開放 → 成功回復/継続熔断
